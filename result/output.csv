title,meta_desc,body
2s complement in C - javatpoint,"2s complement in C with Tutorial, C language with programming examples for beginners and professionals covering concepts, c array, c pointers, c structures, c union, c strings etc.","<div id=""city"">
<table>
<tr><td>

<h1 class=""h1"">What is the 2s complement in C?</h1>
<p>The 2s complement in C is generated from the 1s complement in C. As we know that the 1s complement of a binary number is created by transforming bit 1 to 0 and 0 to 1; the 2s complement of a binary number is generated by adding one to the 1s complement of a binary number.</p>
<p>In short, we can say that the 2s complement in C is defined as the sum of the one's complement in C and one.</p>
<img alt=""2s complement in C"" src=""https://static.javatpoint.com/cpages/images/2s-complement-in-c.png""/>
<p>In the above figure, the binary number is equal to 00010100, and its one's complement is calculated by transforming the bit 1 to 0 and 0 to 1 vice versa. Therefore, one's complement becomes 11101011. After calculating one's complement, we calculate the two's complement by adding 1 to the one's complement, and its result is 11101100.</p>
<p>Let's create a program of 2s complement.</p>
<div class=""codeblock""><textarea class=""Cpp"" name=""code"">
#include &lt;stdio.h&gt;
int main()
{
   int n;  // variable declaration
   printf(""Enter the number of bits do you want to enter :"");
   scanf(""%d"",&amp;n);
   char binary[n+1];  // binary array declaration; 
   char onescomplement[n+1]; // onescomplement array declaration 
   char twoscomplement[n+1]; // twoscomplement array declaration
   int carry=1; // variable initialization
   printf(""\nEnter the binary number : "");
   scanf(""%s"", binary);
   printf(""%s"", binary);
   printf(""\nThe ones complement of the binary number is :"");
   
   // Finding onescomplement in C
   for(int i=0;i&lt;n;i++)
   {
       if(binary[i]=='0')
       onescomplement[i]='1';
       else if(binary[i]=='1')
       onescomplement[i]='0';
   }
   onescomplement[n]='\0';
   printf(""%s"",onescomplement);
  

printf(""\nThe twos complement of a binary number is : "");

// Finding twoscomplement in C
for(int i=n-1; i&gt;=0; i--)
    {
        if(onescomplement[i] == '1' &amp;&amp; carry == 1)
        {
            twoscomplement[i] = '0';
        }
        else if(onescomplement[i] == '0' &amp;&amp; carry == 1)
        {
            twoscomplement[i] = '1';
            carry = 0;
        }
        else
        {
            twoscomplement[i] = onescomplement[i];
        }
    }
twoscomplement[n]='\0';
printf(""%s"",twoscomplement);
return 0;
}
</textarea></div>
<p><strong>Output</strong></p>
<img alt=""2s complement in C"" src=""https://static.javatpoint.com/cpages/images/2s-complement-in-c2.png""/>
<h3 class=""h3"">Analysis of the above program,</h3>
<ul class=""points"">
<li>First, we input the number of bits, and it gets stored in the '<strong>n</strong>' variable.</li>
<li>After entering the number of bits, we declare character array, i.e., <strong>char binary[n+1],</strong> which holds the binary number. The '<strong>n</strong>' is the number of bits which we entered in the previous step; it basically defines the size of the array.</li>
<li>We declare two more arrays, i.e., <strong>onescomplement[n+1]</strong>, and <strong>twoscomplement[n+1].</strong> The <strong>onescomplement[n+1]</strong> array holds the ones complement of a binary number while the <strong>twoscomplement[n+1]</strong> array holds the two's complement of a binary number.</li>
<li>Initialize the <strong>carry</strong> variable and assign 1 value to this variable.</li>
<li>After declarations, we input the binary number.</li>
<li>Now, we simply calculate the one's complement of a binary number. To do this, we create a <strong>loop</strong> that iterates throughout the binary array, <strong>for(int i=0;i&lt;n;i++)</strong>. In for loop, the condition is checked whether the bit is 1 or 0. If the bit is 1 then <strong>onescomplement[i]=0</strong> else <strong>onescomplement[i]=1</strong>. In this way, one's complement of a binary number is generated.</li>
<li>After calculating one's complement, we generate the 2s complement of a binary number. To do this, we create a <strong>loop</strong> that iterates from the last element to the starting element. In for loop, we have three conditions:
<ul class=""points"">
<li>If the bit of onescomplement[i] is 1 and the value of carry is 1 then we put 0 in twocomplement[i].</li>
<li>If the bit of onescomplement[i] is 0 and the value of carry is 1 then we put 1 in twoscomplement[i] and 0 in carry.</li>
<li>If the above two conditions are false, then onescomplement[i] is equal to twoscomplement[i].</li>
</ul></li>
</ul>
<p><strong><em>Signed integers</em></strong> are frequently represented in C using the <strong><em>two's complement notation</em></strong>. Using the same <strong><em>binary representation</em></strong> offers a mechanism to express both <strong><em>positive</em></strong> and <strong><em>negative integers</em></strong>. The <strong><em>most significant bit (MSB)</em></strong> is used as the <strong><em>sign bit</em></strong> in a <strong><em>two's complement representation</em></strong>, where <strong><em>0</em></strong> denotes a <strong><em>positive integer</em></strong>, and <strong><em>1</em></strong> denotes a <strong><em>negative number</em></strong>.</p>
<p>Starting with a <strong><em>negative number's</em></strong> absolute value in binary form, you may take the <strong><em>one's complement (bitwise negation)</em></strong> of that value to get the <strong><em>two's complement</em></strong> representation of the <strong><em>negative integer</em></strong>. You add <strong><em>1</em></strong> to the <strong><em>resultant value</em></strong> to acquire the representation of the <strong><em>two's complement</em></strong>.</p>
<p>The <strong><em>two's complement encoding</em></strong> in C can represent <strong><em>signed integers</em></strong> and can perform fast arithmetic operations. One benefit of employing two's complement is the ability to do <strong><em>addition</em></strong> and <strong><em>subtraction</em></strong> using the same binary operations as for unsigned numbers.</p>
<p>The <strong><em>binary numbers</em></strong> are added together like <strong><em>unsigned integers</em></strong> when adding two's complement. A carry-out from the location of the <strong><em>main critical bit</em></strong> is just disregarded. Due to this fact, handling <strong><em>signed numbers</em></strong> differently is not necessary, and addition becomes simple.</p>
<p>Consider adding <strong><em>-5</em></strong> and <strong><em>-3</em></strong> using the <strong><em>8-bit two's complement</em></strong> representation, for instance:</p>
<p>Binary number for <strong><em>-5</em></strong> is <strong><em>11111011.</em></strong></p>
<p>Binary number for <strong><em>-3</em></strong> is <em>11111101</em>.</p>
<p>carrying out the addition:</p>
<div class=""codeblock""><textarea class=""Cpp"" name=""code"">
    11111011 (-5)
  + 11111101 (-3)
    -------------
    111110100 (-8)
</textarea></div>
<p>The answer is <strong><em>111110100</em></strong>, which in <strong><em>two's complement</em></strong> is equal to <strong><em>-8</em></strong>.</p>
<p>Similar to addition, subtraction may be done by treating the <strong><em>second operand's</em></strong> two's complement as if it were addition. In other words, you add the two's complement of a negative number to the first operand to remove it.</p>
<p>For instance, when <strong><em>-3</em></strong> is subtracted from <strong><em>-5</em>:</strong></p>
<p>In binary, <strong><em>-5</em></strong> is represented by <strong><em>11111011</em></strong> and <strong><em>-(-3)</em></strong> by <strong><em>00000011</em></strong> (two's complement of <strong><em>-3</em></strong>)</p>
<p>Carrying out the subtraction</p>
<div class=""codeblock""><textarea class=""Cpp"" name=""code"">
    11111011 (-5)
  + 00000011 (+3)
    -------------
    11111110 (-8)
</textarea></div>
<p>The outcome is <strong><em>11111110</em></strong>, which in two's complement is equal to <strong><em>-8</em></strong>.</p>
<h2 class=""h2"">Conclusion:</h2>
<p>In C, the <strong><em>2s complement</em></strong> is a binary representation of a negative number that is created by adding one to the <strong><em>1s complement</em></strong>. Computer systems frequently employ this idea to represent signed numbers and efficiently carry out arithmetic operations.</p>
<p>To get the <strong><em>2s complement</em></strong> of a binary integer, one must first determine the <strong><em>1s complement</em></strong> of the number by flipping the bits. After that, the representation of the <strong><em>2s complement</em></strong> is obtained by <strong><em>adding one</em></strong> to the <strong><em>1s complement</em></strong>. The <strong><em>most significant bit (MSB)</em></strong> will function as a sign bit by expressing whether a number is <strong><em>positive</em></strong> or <strong><em>negative</em></strong>.</p>
<p>The computation of the <strong><em>2s complement</em></strong> for a given binary integer is shown in the attached C program. The user is prompted to input both the <strong><em>binary number</em></strong> and the number of bits. After that, the program does the required procedures to acquire the 1s complement, and then the <strong><em>2s complement</em></strong>. The findings are then shown.</p>
<p>In computer science and programming, it's crucial to comprehend the <strong><em>2s complement</em></strong> representation since it makes it possible to handle negative values expressed in binary effectively. It makes <strong><em>addition, subtraction</em></strong>, and <strong><em>logical operations</em></strong> simpler on both <strong><em>positive</em></strong> and <strong><em>negative numbers</em></strong>. The range of <strong><em>representable integers</em></strong> is symmetric about <strong><em>zero</em></strong> due to the <strong><em>2s complement</em></strong> representation, making it appropriate for various numerical operations.</p>
<p>Programmers may conduct arithmetic operations, work with binary data, and design algorithms using signed integers in C and other programming languages by understanding the idea of 2s complement and properly utilizing it.</p>
<hr/>

<br/><br/>

</td></tr>
</table>
</div>"
Difference between 32 bit and 64 bit Operating System - javatpoint,"Difference between 32 bit and 64 bit Operating System with OS Tutorial, Types of OS, Process Management Introduction, Attributes of a Process, CPU Scheduling, FCFS with overhead, FCFS Scheduling etc.","<div id=""city"">
<table>
<tr><td>

<h1 class=""h1"">Difference between 32 bit and 64 bit Operating System</h1>
<p>In computing, a byte is the unit of data, and processing is generally denoted as bit processing. In general, there exist two types of processors, namely a <a href=""https://www.javatpoint.com/32-bit-vs-64-bit-processors"">32-bit processor and a 64-bit processor</a>. This type of processor tells us how much memory a processor can have access from a CPU register. </p>
<img alt=""32 bit vs 64 bit Operating System"" src=""https://static.javatpoint.com/operating-system/images/32-bit-vs-64-bit-operating-system.png""/>
<ul class=""points"">
<li>A 32-bit system can access 2<sup>32</sup> memory addresses, i.e., 4 GB of RAM or physical memory; ideally, it can also access more than 4 GB of RAM.</li>
<li>A 64-bit system can access 2<sup>64</sup> memory addresses, i.e., actually 18-Quintillion bytes of RAM. In short, any amount of memory greater than 4 GB can be easily handled by it.</li>
</ul>
<p>With an increase in the availability of 64-bit processors and larger RAM capacities, Microsoft and Apple both have upgraded versions of their operating systems designed to take full advantage of the new technology. The first fully 64-bit operating system was Mac OS X Snow Leopard in 2009. Meanwhile, the first Smartphone with a 64-bit chip (Apple A7) was the iPhone 5s.</p>
<h3 class=""h3"">What is 32-Bit Operating System?</h3>
<p>It is a <a href=""central-processing-unit.html"">CPU</a> architecture type that holds the capacity to transfer 32 bits of data. It refers to the amount of data and information that your <a href=""cpu-full-form.html"">CPU</a> can easily process when operating. A majority of the computers produced in the early 2000s and 1990s were 32-bit machines.</p>
<p>One bit in the register can typically reference an individual byte. Thus, the 32-bit system is capable of addressing about 4,294,967,296 bytes (4 GB) of <a href=""ram.html"">RAM</a>. Its actual limit is less than 3.5 GB (usually) because a portion of the register stores various other temporary values apart from the memory addresses.</p>
<h3 class=""h3"">What is 64-Bit Operating System?</h3>
<p>The 64-bit microprocessor allows computer systems to process information, data, and memory addresses represented by 64 bits. Such a system can typically reference 16 exabytes (17,179,869,184 GB), or 18,446,744,073,709,551,616 bytes of memory.</p>
<p>A 64-bit system (a computer with a 64-bit processor) can access more than 4 GB of RAM. It is numerous million times more than what an average workstation would require to access. It means that if a computer has 8 GB of <a href=""ram-full-form.html"">RAM</a>, it requires a 64-bit processor. Or else, the CPU will be inaccessible to at least 4 GB of the memory.</p>
<h3 class=""h3"">Advantages of 64-bit over the 32-bit operating system</h3>
<p>Below are the following advantages of a 64-bit operating system over the 32-bit operating system, such as:</p>
<img alt=""32 bit vs 64 bit Operating System"" src=""https://static.javatpoint.com/operating-system/images/32-bit-vs-64-bit-operating-system2.png""/>
<ol class=""points"">
<li><strong>Addressable memory:</strong> 32-bit operating systems can address a maximum of 4 GB of RAM. But 64-bit operating system can address up to 17,179,869,184 GB (16 exabytes). That's a lot more than 4GB of memory that a 32-bit operating system can handle.</li>
<li><strong>Available Resources:</strong> The 64-bit operating system can make full use of available system resources compared to a 32-bit system. To simplify, installing more RAM on a system with a 32-bit OS doesn't impact performance. However, upgrade that system with excess RAM to the 64-bit version of Windows, and you'll notice a difference.</li>
<li><strong>Computer Performance:</strong> The system can perform more calculations per second using a 64-bit system with a 64-bit processer. As a result, it increases the processing power and makes a computer run faster. This is limited in the case of 32-bit operating systems.</li>
<li><strong>Software performance:</strong> More software's are written to leverage the benefit of a 64-bit operating system fully. If you are using a 64-bit operating system and install software of 64 bit, you can up-front notice the increase in performance. It becomes even more critical when performing a huge operation that requires the system to access more memory. An increase in software performance leads results in an increase in overall efficiency.</li>
<li><strong>Multitasking:</strong> Using 64-bit, users can do various things in multitasking at the same time. Users can easily switch between various applications without any windows hanging problems.</li>
</ol>
<h3 class=""h3"">Difference between 32-bit and 64-bit OS</h3>
<p>A 64-bit processor is more capable than a 32-bit processor because it can handle more data at once. A 64-bit processor can store more computational values, including memory addresses, which means it can access over 4 billion times the physical memory of a 32-bit processor.</p>
<p>Here is the key difference, 32-bit processors are perfectly capable of handling a limited amount of RAM (in Windows, 4GB or less), and 64-bit processors can utilize much more. A major difference between <strong>32-bit processors and 64-bit processors</strong> is the number of <strong><em>calculations per second</em></strong> they can perform, which affects the speed at which they can complete tasks. Below are some more differences between 32-bit and 64-bit operating systems, such as:</p>
<table class=""alt"">
<tr>
<th>Parameters</th>
<th>32-bit Processors</th>
<th>64-bit Processors</th>
</tr>
<tr>
<td>Handling of Data and Storage</td>
<td>As its name suggests, the 32 bit OS can store and handle lesser data than the 64 bit OS. More specifically, it addresses a maximum of 4,294,967,296 bytes (4 GB) of RAM.</td>
<td>The 64 bit OS, on the other hand, can handle more data than the 32 bit OS. It means that it can address a total of 264 memory addresses, which is 18-Quintillion GB of RAM.</td>
</tr></table></td>
<tr>
<td>Architecture</td>
<td>The 32-bit system has general computing, including IBM System/360 and IBM System/370, the DEC VAX, the Motorola 68000 Family, the Intel IA-32, and the 32-bit version of x86 architecture different versions. These are architectures that are used for embedded computing and include 68000 families.</td>
<td>The registers are divided into different groups like integer, floating, control and often for addresses of various uses and names like address, index or base registers. The size of these registers is dependent on the amount of addressable memory.</td>

<tr>
<td>Compatibility of System</td>
<td>A 32-bit processor system could properly run a 32-bit OS, but it cannot run the 64-bit OS at its full capability.</td>
<td>A 64-bit processor system can run either a 32-bit or 64-bit version of an installed operating system (OS).</td>

<tr>
<td>Performance</td>
<td>The factor of performance in a 32-bit processor is less efficient than the 64-bit processor.</td>
<td>It exhibits a higher performance than the 32-bit processor.</td>

<tr>
<td>Application Support</td>
<td>The 64-bit programs and applications won't work.</td>
<td>The 32-bit programs and applications will work with no hassle.</td>

<tr>
<td>Addressable Space</td>
<td>It has an addressable space of 4 GB.</td>
<td>These have an addressable space of 16 GB.</td>

<tr>
<td>Calculation per second</td>
<td>32-bit systems have dual-core and quad-core versions available.</td>
<td>64bit systems can come with dual-core, quad-core, six-core, and eight-core versions. Having these multiple cores available has increased its speed of calculations per second.</td>

<tr>
<td>Multitasking Support</td>
<td>The 32-bit system is not an ideal option for multitasking and stress-testing.</td>
<td>For multitasking and stress testing, the 64-bit processor is better. It also works well for the execution of other heavy applications.</td>

<tr>
<td>OS Support</td>
<td>It needs a 32-bit operating system.</td>
<td>This one can run on both 32-bit and the 64-bit operating system.</td>

<tr>
<td>OS and CPU Requirements</td>
<td>The 32-bit applications and operating systems require 32-bit CPUs.</td>
<td>The 64-bit operating system needs a 64-bit CPU, and the 64-bit applications require a 64-bit CPU and OS.</td>

<tr>
<td>Systems Available</td>
<td>These support Windows 7, Windows XP, Windows Vista, Windows 8, and Linux.</td>
<td>These support Windows XP Professional, Windows 7, Windows 8, Windows 10, Windows Vista, Linux, and Mac OS X.</td>

<tr>
<td>Limits in Memory</td>
<td>A 32-bit system has a limit of 32 bit Windows 3.2 GB of RAM. The limit in its addressable space doesn't allow you to use the entire physical memory space of 4GB.</td>
<td>A 64-bit system enables its users to store up to 17 Billion GB of RAM.</td>

</tr>
</tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></table>
<h3 class=""h3"">How to Choose Processors?</h3>
<p>While a 64-bit processor has more processing power than a 32-bit processor, it does not always mean that you need a 64-bit computer or software. Whether you should install a 32-bit or 64-bit application on your computer depends on your current setup.</p>
<p>If you want your computer to be fast, you should probably choose a 64-bit processor. You can even use this processor if you're running 32-bit programs since most applications are backwards compatible. It means 64-bit computers will run most 32-bit programs. However, a 32-bit computer will not run any 64-bit applications. Here are some reasons why you might want to upgrade to a 64-bit processor:</p>
<ul class=""points"">
<li><strong>Graphics:</strong> Aside from being able to handle more data, the 64-bit processor delivers better graphics performance. It means that your computer will be faster when launching apps, editing photos and playing graphic-intensive games.</li>
<li><strong>Security:</strong> A 64-bit computer may still get infected by malware (malicious software), including viruses, spyware, Trojans, and ransomware. However, a computer with a 64-bit system has more security features than a 32-bit system.</li>
</ul>
<hr/>

<br/><br/>

<br/><br/>


</div>"
5 State Process Model in Operating System - javatpoint,"5 State Process Model in Operating System with OS Tutorial, Types of OS, Process Management, Attributes of a Process, CPU Scheduling, FCFS with overhead, FCFS Scheduling etc.","<div id=""city"">
<table>
<tr>
<td>

<h1 class=""h1"">5 State Process Model in Operating System</h1>
<p>The <strong>Five-State Process</strong> Model is developed from the <strong>Two-State Model</strong>.
                  If all processes in the Not-running state are ready to run, the two-stage model is efficient; however,
                  it is not always true. Some processes in the Not-running state may be waiting for an event or
                  performing an I/O activity. A process must be created for each program to run a program. The process
                  can or cannot run, but if a process is running, it has to be supported by the operating system for the
                  right progress of the process to be gained.</p>
<p>The best way to fix this issue is to divide the Not-running state into two states:
                  <strong>Ready</strong> and <strong>Blocked</strong> state.
                </p>
<h2 class=""h2"">Reason for New State</h2>
<p>The main memory in previous models was considered to be large enough to accommodate all programs, but
                  this is not the case. The size of today's programs is very large. It is not possible to load all
                  processes into the main memory.</p>
<p>The program does not load into the main memory for the new process when creating a new process. In
                  the main memory, the operating system only saves a little amount of information about the process.
                  When enough space is available, the long term scheduler sends the program to the main memory. Such a
                  process is said to be in a new state.</p>
<h2 class=""h2"">Reason for Terminated State</h2>
<p>When a process completes execution in the previous models, its resources are instantly released.
                  However, another process may require this data in the future.</p>
<p>The child process is considered to be at an end-of-life condition. The child's process is still in
                  memory but cannot be executed. For example, when a child process completes execution, the operating
                  system saves its data till the parent call waits () function.</p>
<h2 class=""h2"">Five-state process model states</h2>
<p>The five states that are being used in this process model are as follows:</p>
<p><strong>1. New</strong></p>
<p>It refers to a new process that has been created but has not yet been approved for execution by the
                  operating system. Although a new process has not been loaded into the main memory, its process control
                  block has been created.</p>
<p><strong>2. Ready</strong></p>
<p>After a new state process, a process moves from a new to a ready state. When a process is in the
                  ready state, it signifies it has been loaded into the main memory and is ready to run. In the ready
                  state, the process must wait for the processor to respond; once the processor responds, the process
                  advances to the processor for execution. It's worth noting that several processes in a
                  multi-programming environment can remain in the ready state.</p>
<p><strong>3. Running</strong></p>
<p>All of the processes that are executing on the CPU are in the running state.</p>
<p>The running state indicates that the procedure is starting from a new and ready state. If the process
                  is in its critical section, other processes must wait in the Ready state.</p>
<p><strong>4. Blocked/Waiting</strong></p>
<p>The blocked state applies to all processes that quit the CPU and enter the waiting state. When the
                  CPU becomes available, processes in the blocked state are moved to the ready state and then to the
                  running state.</p>
<p><strong>5. Exit/Terminated</strong></p>
<p>The exit state refers to a process that has been terminated from the CPU and the main memory.</p>
<h2 class=""h2"">Execution of Five-state process in Two-state Model</h2>
<p>This model has five states: new, ready, running, blocked, and exit. When a new job/process arrives in
                  the queue, it is first accepted to the queue and then moves to the ready state. The process is now in
                  the running state while in the Ready state. A process in the running state has two conditions: it
                  either proceeds to the event wait, or it times out.</p>
<img alt=""5 State Process Model in Operating System"" src=""https://static.javatpoint.com/operating-system/images/5-state-process-model-in-operating-system.png""/>
<p>If the process has timed out, it moves to the ready state because the process has not finished its
                  execution. If a process has an event wait condition, it enters the blocked state and the ready state.
                  If both conditions are true, the process enters a running state after dispatching, and following
                  which, it is freed and finally terminated.</p>
<h2 class=""h2"">Five-State Process Model State Transitions</h2>
<p>Various events lead to a process's state shift. The 5-state process model's probable state
                  transitions are given below:</p>
<p><strong>1. Null -&gt; New</strong></p>
<p>A new process is created for the implementation of a process.</p>
<p><strong>2. New -&gt; Ready</strong></p>
<p>The system would transition the process from new to ready, and it is now ready for running. In this
                  instance, a system may set a restriction to prohibit many processes from running concurrently;
                  otherwise, performance may suffer.</p>
<p><strong>3. Ready -&gt; Running</strong></p>
<p>The operating system now chooses a process for running, and the system selects single process in a
                  ready state for running.</p>
<p><strong>4. Running -&gt; Exit</strong></p>
<p>If a process indicates that it is now complete or has been aborted, the system terminates it.</p>
<p><strong>5. Running -&gt; Ready</strong></p>
<p>This transition occurs when the running process has achieved its maximum running time for continuous
                  execution.</p>
<p><strong>6. Running -&gt; Blocked</strong></p>
<p>If a process requests something for which it is waiting, it is placed in the blocked state. For
                  example, a process can require resources that aren't currently available, or it could be waiting for
                  an Input/Output operation or another process to complete before proceeding.</p>
<p><strong>7. Blocked -&gt; Ready</strong></p>
<p>When the event for which the process has been waiting occurs, the process switches from blocked to
                  ready state.</p>
<p><strong>8. Ready -&gt; Exit</strong></p>
<p>The transition is only allowed in a few circumstances since a parent process can terminate a child's
                  process at any time in some systems.</p>
<h2 class=""h2"">Advantages and Disadvantages of the five-state process model</h2>
<p>There are various advantages and disadvantages of the five-state process model. Some advantages and
                  disadvantages of the five-state process model are as follows:</p>
<h3 class=""h3"">Advantages</h3>
<ol class=""points"">
<li>The New and Exit states are very useful components for process management.</li>
<li>It is a more efficient implementation of the preceding two-state process concept.</li>
</ol>
<h3 class=""h3"">Disadvantages</h3>
<ol class=""points"">
<li>The data of a process that is terminated or exited from the OS is not saved by the OS.</li>
<li>When each process enters a blocked state, the processor remains idle until at least one process
                    exits the waiting state, which might cause a performance issue.</li>
</ol>
<hr/>

<br/><br/>

<br/><br/>
</td>
</tr>
</table>
</div>"
8 Puzzle problem in Python - Javatpoint,"8 Puzzle problem in Python with Python with python, tutorial, tkinter, button, overview, canvas, frame, environment set-up, first python program, operators, etc.","<div id=""city"">
<table>
<tr>
<td>

<h1 class=""h1"">8 Puzzle problem in Python</h1>
<p>The 8 puzzle problem solution is covered in this article. A <strong>3 by 3 board with
										8 tiles</strong> (each tile has a number from 1 to 8) and a <strong>single empty
										space</strong> is provided. The goal is to <strong>use the vacant space to
										arrange the numbers on the tiles</strong> such that they match the final
									arrangement. <strong>Four neighbouring</strong> (left, right, above, and below)
									<strong>tiles</strong> can be moved into the available area.</p>
<p>For instance,</p>
<img alt=""8 Puzzle problem in Python"" src=""https://static.javatpoint.com/python/images/8-puzzle-problem-in-python.png""/>
<h3 class=""h3"">1. DFS (Brute - Force) :</h3>
<p>On the state-space tree (Set of all configurations of a particular issue, i.e., all
									states that may be reached from the beginning state), we can do a
									<strong>depth-first search</strong>.</p>
<img alt=""8 Puzzle problem in Python"" src=""https://static.javatpoint.com/python/images/8-puzzle-problem-in-python2.png""/>
<p><strong>Figure : 8 Puzzle's State Space Tree</strong></p>
<p>In this solution, <strong>further movements might not always send us closer to the
										objective</strong>, but rather further <strong>away</strong>. Regardless of the
									<strong>initial state</strong>, the <strong>state-space tree searches down</strong>
									the leftmost route from the root. With this method, an answer node might
									<strong>never be discovered</strong>.</p>
<h3 class=""h3"">2. BFS (Brute - Force) :</h3>
<p>We can search the state space tree using a <strong>breadth-first approach</strong>.
									It always locates the <strong>goal state that is closest to the root</strong>.
									However, the algorithm tries the <strong>same series of movements as DFS</strong>
									regardless of the initial state.</p>
<h3 class=""h3"">3. Branch and Bound :</h3>
<p>By avoiding searching in sub-trees which do not include an answer node, an
									<strong>""intelligent"" ranking function</strong>, also known as an
									<strong>approximatsion costs function</strong>, may frequently <strong>speed up the
										search for an answer node</strong>. However, instead of using the backtracking
									method, it does a <strong>BFS-style search</strong>.</p>
<p>Basically, <strong>Branch and Bound</strong> involves three different kinds of nodes.
								</p>
<ol class=""points"">
<li>A <strong>live node</strong> is a created node whose children have not yet been
										formed.</li>
<li>The offspring of the <strong>E-node</strong> which is a live node, are now being
										investigated. Or to put it another way, an E-node is a node that is currently
										expanding.</li>
<li>A created node which is not to be developed or examined further is referred to
										as a <strong>dead node</strong>. A dead node has already extended all of its
										offspring.</li>
</ol>
<h3 class=""h3"">Costs function :</h3>
<p>In the search tree, each <strong>node Y</strong> has a corresponding costs. The next
									<strong>E-node</strong> may be found using the <strong>costs function</strong>. The
									E-node with the <strong>lowest costs</strong> is the next one. The function can be
									defined as :</p>
<div class=""codeblock""><textarea class=""python"" name=""code"">
C(Y) = g(Y) + h(Y) 
where
   g(Y) = the costs of reaching to the current node 
          from the root.
   h(Y) = the costs of reaching to an answer node from the Y.
</textarea></div>
<p><strong>The optimum costs function for an algorithm for 8 puzzles is :</strong></p>
<p>We suppose that it will costs <strong>one unit</strong> to move a tile in any
									direction. In light of this, we create the following costs function for the 8-puzzle
									algorithm :</p>
<div class=""codeblock""><textarea class=""python"" name=""code"">
c(y) = f(y) + h(y) 
where
   f(y) = the path's total length from the root y. 
   and
   h(y) = the amount of the non-blank tiles which are not in 
        their final goal position (misplaced tiles).

To change state y into a desired state, there are at least h(y) movements required.
</textarea></div>
<p>There is an algorithm for <strong>estimatsing the unknown value of h(y),</strong>
									which is accessible.</p>
<h3 class=""h3"">Final algorithm :</h3>
<ul class=""points"">
<li>In order to maintain <strong>the list of live nodes</strong>, algorithm
										<strong>LCSearch</strong> employs the functions <strong>Least()</strong> and
										<strong>Add().</strong></li>
<li><strong>Least()</strong> identifies a live node with the <strong>least
											c(y),</strong> removes it from the list, and returns it.</li>
<li><strong>Add(y)</strong> adds <strong>y</strong> to the list of live nodes.</li>
<li><strong>Add(y)</strong> implements the list of live nodes as a
										<strong>min-heap</strong>.</li>
</ul>
<p>The route taken by the aforementioned algorithm to arrive at the final configuration
									of the 8-Puzzle from the starting configuration supplied is shown in the
									<strong>diagram below</strong>. Keep in mind that only <strong>nodes with the lowest
										costs function</strong> value are extended.</p>
<img alt=""8 Puzzle problem in Python"" src=""https://static.javatpoint.com/python/images/8-puzzle-problem-in-python3.png""/>
<h3 class=""h3"">Code :</h3>
<div class=""codeblock""><textarea class=""python"" name=""code"">
# Python code to display the way from the root
# node to the final destination node for N*N-1 puzzle
# algorithm by the help of Branch and Bound technique
# The answer assumes that the instance of the
# puzzle can be solved

# Importing the 'copy' for deepcopy method
import copy

# Importing the heap methods from the python
# library for the Priority Queue
from heapq import heappush, heappop

# This particular var can be changed to transform
# the program from 8 puzzle(n=3) into 15
# puzzle(n=4) and so on ...
n = 3

# bottom, left, top, right
rows = [ 1, 0, -1, 0 ]
cols = [ 0, -1, 0, 1 ]

# creating a class for the Priority Queue
class priorityQueue:
	
	# Constructor for initializing a
	# Priority Queue
	def __init__(self):
		self.heap = []

	# Inserting a new key 'key'
	def push(self, key):
		heappush(self.heap, key)

	# funct to remove the element that is minimum,
	# from the Priority Queue
	def pop(self):
		return heappop(self.heap)

	# funct to check if the Queue is empty or not
	def empty(self):
		if not self.heap:
			return True
		else:
			return False

# structure of the node
class nodes:
	
	def __init__(self, parent, mats, empty_tile_posi,
				costs, levels):
					
		# This will store the parent node to the
		# current node And helps in tracing the
		# path when the solution is visible
		self.parent = parent

		# Useful for Storing the matrix
		self.mats = mats

		# useful for Storing the position where the
		# empty space tile is already existing in the matrix
		self.empty_tile_posi = empty_tile_posi

		# Store no. of misplaced tiles
		self.costs = costs

		# Store no. of moves so far
		self.levels = levels

	# This func is used in order to form the
	# priority queue based on
	# the costs var of objects
	def __lt__(self, nxt):
		return self.costs &lt; nxt.costs

# method to calc. the no. of
# misplaced tiles, that is the no. of non-blank
# tiles not in their final posi
def calculateCosts(mats, final) -&gt; int:
	
	count = 0
	for i in range(n):
		for j in range(n):
			if ((mats[i][j]) and
				(mats[i][j] != final[i][j])):
				count += 1
				
	return count

def newNodes(mats, empty_tile_posi, new_empty_tile_posi,
			levels, parent, final) -&gt; nodes:
				
	# Copying data from the parent matrixes to the present matrixes
	new_mats = copy.deepcopy(mats)

	# Moving the tile by 1 position
	x1 = empty_tile_posi[0]
	y1 = empty_tile_posi[1]
	x2 = new_empty_tile_posi[0]
	y2 = new_empty_tile_posi[1]
	new_mats[x1][y1], new_mats[x2][y2] = new_mats[x2][y2], new_mats[x1][y1]

	# Setting the no. of misplaced tiles
	costs = calculateCosts(new_mats, final)

	new_nodes = nodes(parent, new_mats, new_empty_tile_posi,
					costs, levels)
	return new_nodes

# func to print the N by N matrix
def printMatsrix(mats):
	
	for i in range(n):
		for j in range(n):
			print(""%d "" % (mats[i][j]), end = "" "")
			
		print()

# func to know if (x, y) is a valid or invalid
# matrix coordinates
def isSafe(x, y):
	
	return x &gt;= 0 and x &lt; n and y &gt;= 0 and y &lt; n

# Printing the path from the root node to the final node
def printPath(root):
	
	if root == None:
		return
	
	printPath(root.parent)
	printMatsrix(root.mats)
	print()

# method for solving N*N - 1 puzzle algo
# by utilizing the Branch and Bound technique. empty_tile_posi is
# the blank tile position initially.
def solve(initial, empty_tile_posi, final):
	
	# Creating a priority queue for storing the live
	# nodes of the search tree
	pq = priorityQueue()

	# Creating the root node
	costs = calculateCosts(initial, final)
	root = nodes(None, initial,
				empty_tile_posi, costs, 0)

	# Adding root to the list of live nodes
	pq.push(root)

	# Discovering a live node with min. costs,
	# and adding its children to the list of live
	# nodes and finally deleting it from
	# the list.
	while not pq.empty():

		# Finding a live node with min. estimatsed
		# costs and deleting it form the list of the
		# live nodes
		minimum = pq.pop()

		# If the min. is ans node
		if minimum.costs == 0:
			
			# Printing the path from the root to
			# destination;
			printPath(minimum)
			return

		# Generating all feasible children
		for i in range(n):
			new_tile_posi = [
				minimum.empty_tile_posi[0] + rows[i],
				minimum.empty_tile_posi[1] + cols[i], ]
				
			if isSafe(new_tile_posi[0], new_tile_posi[1]):
				
				# Creating a child node
				child = newNodes(minimum.mats,
								minimum.empty_tile_posi,
								new_tile_posi,
								minimum.levels + 1,
								minimum, final,)

				# Adding the child to the list of live nodes
				pq.push(child)

# Main Code

# Initial configuration
# Value 0 is taken here as an empty space
initial = [ [ 1, 2, 3 ],
			[ 5, 6, 0 ],
			[ 7, 8, 4 ] ]

# Final configuration that can be solved
# Value 0 is taken as an empty space
final = [ [ 1, 2, 3 ],
		[ 5, 8, 6 ],
		[ 0, 7, 4 ] ]

# Blank tile coordinates in the 
# initial configuration
empty_tile_posi = [ 1, 2 ]

# Method call for solving the puzzle
solve(initial, empty_tile_posi, final)
</textarea></div>
<p><strong>Output:</strong></p>
<div class=""codeblock3"">
<pre>
1 2 3 
5 6 0 
7 8 4 

1 2 3 
5 0 6 
7 8 4 

1 2 3 
5 8 6 
7 0 4 

1 2 3 
5 8 6 
0 7 4
</pre>
</div>
<hr/>

<br/><br/>

<br/><br/>
</td>
</tr>
</table>
</div>"
